/* 1) overview

    - what is STL
    - generic programming / meta programming
        - preprocessor macros
        - function templates
        - class templates
    - stl containers
    - stl iterators
    - stl algorithms
    - array
    - vector
    - deque
    - list and forward list
    - set and multiset
    - map and multimap
    - stack and queue
    - priority queue
    - algorithms

 */


/* 2) what is stl

    - a library of powerful, reusable, adaptable, generic classes and functions
    - implemented using c++ templates
    - implements common data structures and algorithms
    - huge class library


    why use the stl?
    - assortment of commonly used containers
    - known time and size complexity
    - tried and tested - reusability
    - consistent, fast, and type safe
    - extensible

    elements of stl
    ----------------
    - containers
        - collection of objects or primitive types
            (array, vector, deque, stack, set, map etc.)
        
    - algorithms
        - functions for processing sequences of elements from containers
            (find, max, count, accumulate, sort, etc.)

    - iterators
        - generate sequences of elements from containers
            (forward, reverse, by value, by reference, constant, etc)


    types of containers
    ------------------
    - sequence of containers
        - array, vector, list, forward_list, deque
    
    - associative containers
        - set, multiset, map, multimap
    
    - container adapters
        - stack, queue, priority queue

    types of iterators
    -----------------
    - input iterators - from the container to the program
    - output iterators - from the program to the container
    - forward iterators - navigate one item at a time in one direction
    - bidirectional iterators - navigate one item at a time both directions
    - random access iterators - directly access a container item

    types of algoritms
    -  about 60 algorithms in stl
    - non modifying
    - modifying
    

*/

/* 3) generic programming with macros 

    generic programming 
        - writing code that works with a variety of types as arguments, as long as those 
        argument types meet specific syntactic and semantic requirements

    - macros ***beware***
    - function templates
    - class templates

    Macros (#define)

    - c++ preprocessor directives
    - no type information
    - simple substitution

        #define MAX_SIZE 100
        #define PI 3.14

    #define MAX(a, b) ((a > b) ? a : b)
    cout << MAX(10, 20); // 20
    cout << MAX(2.4, 3.4); // 3.4
    

    - we have to be careful with macros
        #define SQUARE(a) a*a

        result = SQUARE(5); // EXPECT AND GETS 25

        result = 100 / SQUARE(5); // expect 4 and gets 100



        soln:
            wrap up macros
            #define SQUARE(a) ((a) * (a))  // note the parenthesis

*/


/* 4) generic programming with function templates 

    - what is c++ template?
        - blue print
        - function and class templates
        - allow plugging in any data type
        - compiler generates the appropriate function / class from the blue print
        - generic programming / meta - programming

    max function as a template function

    - we can replace type we want to generalize with a name, say T
    - but now this won't compile
    - we need to tell the compiler this is a template function
    - we also need to tell it that T is the template parameter
    - code is not generated by the compiler until the user uses a specialized version of the template
    - many times the compiler can deduce the type and the template parameter is not needed
    - depending on the type of a and b, the compiler will figure it out


    template <typename T>
    T max(T a, T b){
        return (a > b) ? a : b;
    }

    cout << max<double>(a, b);   
    cout << max<Player>(p1, p2); // will not compile unless player overloads operator >
    

    - multiple types as template parameters
    ---------------------------------------
    - we can have multiple template parameters
    - and their types can be different

        template<typename T1, typename T2>  
        void func(T1 a, T2 b){
            cout << a << b; 
        }
        
        // when we use the function we provide the template parameters
        // ofteh the compiler can deduce them
        func<int, double>(10, 20.2);
        func('A', 12.4);   
        

    // Section 20
    // Function templates
    #include <iostream>
    #include <string>

    template <typename T>
    T min(T a, T b) {
        return (a < b) ? a : b;
    }

    template <typename T1, typename T2>
    void func(T1 a, T2 b) {
        std::cout << a << " " << b << std::endl;
    }

    struct Person {
        std::string name;
        int age;
        bool operator<(const Person &rhs) const {
            return this->age < rhs.age;
        }
    };

    std::ostream &operator<<(std::ostream &os, const Person &p) {
        os << p.name;
        return os;
    }

    template <typename T>
    void my_swap(T &a, T &b) {    
        T temp = a;
        a = b;
        b = temp;
    }

    int main() {
        int x{100};
        int y{200};
        std::cout << x << ", " << y << std::endl;
        my_swap(x, y);
        std::cout << x << ", " << y << std::endl;
        
        Person p1 {"Curly", 15};
        Person p2 {"Moe", 30};
        
        Person p3 = min(p1, p2);
        std::cout << p3.name << " is younger" << std::endl;
        
        func(p1, p2);
        
        std::cout << min<int>(2,3) << std::endl;        // 2
        std::cout << min(2,3) << std::endl;                 // 2
        std::cout << min('A', 'B') << std::endl;            // A
        std::cout << min(12.5, 9.2) << std::endl;        // 9.2
        std::cout << min(5+2*2, 7+40) << std::endl; // 9
        
        func<int,int>(10,20);
        func(10,20);
        func<char, double>('A', 12.4);
        func('A', 12.4);
        func(1000, "Testing");
        func(2000, std::string{"Frank"});
        

        return 0;
    }
*/



/* 5) generic programming with class templates 

    - what is c++ class template?
        - similar to function template, but at the class level
        - allows plugging-in any data type
        - compiler generates the appropriate class from the blueprint

    - Generic programming with class templates
        - but we'd like our Item class to be able to hold any type of data in addtion to the string
        - we can't overload class names 
        - we don't want to use dynamic polymorphism

    // Section 20
    // Class  templates
    #include <iostream>
    #include <string>
    #include <vector>

    // Template classes are typically completely contained in header files
    // So, we would have the template class in Item.h and no Item.cpp file
    // would be used
    template <typename T>
    class Item {
    private:
        std::string name;
        T   value;
    public:
        Item(std::string name, T value) : name{name}, value{value} 
        {}
        std::string get_name() const {return name; }
        T get_value() const { return value; }
    };

    template <typename T1, typename T2>
    struct My_Pair {
        T1 first;
        T2 second;
    };

    int main() {
        
        Item<int> item1 {"Frank", 100};
        std::cout << item1.get_name() << " " << item1.get_value() << std::endl;
        
        Item  <std::string> item2 {"Frank", "Professor"};
        std::cout << item2.get_name() << " " << item2.get_value() << std::endl;
        
        Item <Item<std::string>> item3 {"Frank",  {"C++", "Professor"}};
        std::cout << item3.get_name() << " " 
                        << item3.get_value().get_name() << " "
                        << item3.get_value().get_value() << std::endl;
        
        std::cout << "\n================================" << std::endl;
        std::vector<Item<double>> vec {};
        vec.push_back (Item<double>("Larry", 100.0));
        vec.push_back (Item<double>("Moe", 200.0));
        vec.push_back (Item<double>("Curly",300.0));
        
        for (const auto &item: vec) {
            std::cout << item.get_name() << " " << item.get_value() << std::endl;
        }
    
        std::cout << "\n================================" << std::endl;
        My_Pair <std::string, int> p1 {"Frank", 100};
        My_Pair <int, double> p2 {124, 13.6};

        std::cout << p1.first << ", " << p1.second << std::endl;
        std::cout << p2.first << ", " << p2.second << std::endl;
        
        return 0;
    }

*/


/* 6) creating a generic array template class 

    // Section 20
    // Class template - Array

    // Note: Since C++11 the STL has std::array which is a template-based array class
    // Use std::array instead of raw arrays whenever possible

    // Note that we can have non-type template parameters
    // That's what N is in this case

    #include <iostream>
    #include <string>

    template <typename T, int N>
    class Array {
        int size {N};           // how do we get the N???
        T values[N];        // the N needs to ne known at compile-time!

        friend std::ostream &operator<<(std::ostream &os, const Array<T, N> &arr) {
            os << "[ ";
            for (const auto &val: arr.values)
                os << val << " ";
            os << "]" << std::endl;
            return os;
        }
    public:
        Array() = default;
        Array(T init_val) {
            for (auto &item: values)
                item = init_val;
        }
        void fill(T val) {
            for (auto &item: values )
                item = val;
        }
        int get_size() const {
            return size;
        }
        // overloaded subscript operator for easy use
        T &operator[](int index) {
            return values[index];
        }
    };


    int main() {
        
        Array<int, 5> nums;
        std::cout << "The size of nums is: "<< nums.get_size() << std::endl;
        std::cout << nums << std::endl;
        
        nums.fill(0);
        std::cout << "The size of nums is: "<< nums.get_size() << std::endl;
        std::cout << nums << std::endl;
        
        nums.fill(10);
        std::cout << nums << std::endl;

        nums[0] = 1000;
        nums[3] = 2000;
        std::cout << nums << std::endl;
        
        Array<int, 100> nums2 {1};
        std::cout << "The size of nums2 is: "<< nums2.get_size() << std::endl;
        std::cout << nums2 << std::endl;

        Array<std::string, 10> strings(std::string{"Frank"});
        std::cout << "The size of strings is: "<< strings.get_size() << std::endl;
        std::cout << strings << std::endl;
        
        strings[0] = std::string{"Larry"}; // strings.operator[](0); 
        std::cout << strings << std::endl;
        
        strings.fill(std::string{"X"});
        std::cout << strings << std::endl;

        
        return 0;
    }

*/



/* 7) introduction to stl containers 

    containers
    - data structures that can store object of almost any type
        - template-based classes
    
    - each container has member functions
        - some are specific to the container
        - others are available to all containers
    
    - each containers has an associated header file
        #include <container_type>


    common methods provided by the stl container
    --------------------------------------------
    - default constructor - initializes an empty container
    - overloaded constructors - initializes containers with many options
    - copy constructors - initializes container as a copy of another container
    - move constructor - moves existing container to new container
    - destructor - destroys a container
    - copy assignment (operator=) - copy one container to another
    - move assignment (operator=) - move one container to another
    - size - returns the number of elements in the container
    - empty - returns boolean - is container empty?
    - insert - insert an element into the container

    - operator< and operator<=
    - operator> and operator>= - returns boolean compare contents of 2 containers
    - operator== and operator!= 
    - swap - swap the elements of 2 containers
    - erase - remove element(s) from a container
    - clear - remove all elements from a container
    - begin and end - returns iterators to first element or end
    - rbegin and rend - returns reverse iterators to first element or end
    - cbegin and cend - returns constant iterators to first element or end
    - crbegin and crend - returns constant reverse iterators to first element or end

*/


/* 9) introduction to iterators 

    *** iterator is not pointing to the real pointer

    // Section 20
    // Iterators
    #include <iostream>
    #include <vector>
    #include <set>
    #include <map>
    #include <list>

    // display any vector of integers using range-based for loop
    void display(const std::vector<int> &vec) {
        std::cout << "[ ";
        for (auto const &i: vec) {
            std::cout << i << " ";
        }
        std::cout << "]" << std::endl;
    }

    void test1() {
        std::cout << "\n=============================" << std::endl;
        std::vector<int> nums1 {1, 2, 3, 4, 5};
        auto it = nums1.begin();            // point to 1
        std::cout << *it << std::endl;

        it++;                                           // point to 2
        std::cout << *it << std::endl;      

        it += 2;                                       // point to 4
        std::cout << *it << std::endl;

        it -= 2;                                        // point to 2
        std::cout << *it << std::endl;

        it = nums1.end() - 1;                   // point to 5
        std::cout << *it << std::endl;
    }

    void test2() {
        std::cout << "\n=============================" << std::endl;
        // display all vector elements using an iterator
        
        std::vector<int> nums1 {1, 2, 3, 4, 5};

        std::vector<int>::iterator it = nums1.begin();
        while (it != nums1.end()) {
            std::cout << *it << std::endl;
            it++;
        }
        
        // change all vector elements to 0
        it = nums1.begin();
        while (it != nums1.end()) {
            *it = 0;
            it++;
        }

        display(nums1);
    }

    void test3() {
        
        // using a const_iterator
        std::cout << "\n=============================" << std::endl;
        std::vector<int> nums1 {1, 2, 3, 4, 5};

        std::vector<int>::const_iterator it1 = nums1.begin();
        // auto it1 = nums1.cbegin();
        
        while (it1 != nums1.end()) {
            std::cout << *it1 << std::endl;
            it1++;
        }
        
        // compiler error when we try to change element
        it1 = nums1.begin();
        while (it1 != nums1.end()) {
        // *it1 = 0;   // Complier error - read only
            it1++;
        }

    }

    void test4() {
        // more iterators
        // using a reverse iterator
        std::vector<int> vec {1,2,3,4};
        auto it1  = vec.rbegin();       // reverse iterator over vector of ints starts at 4
        while (it1 != vec.rend()) {
            std::cout << *it1 << std::endl;
            it1++;
        }

        // const reverse iterator over a list
        std::list<std::string> name {"Larry", "Moe", "Curly"};
        auto it2 =name.crbegin();    // iterator over list of strings  point to Curly
        std::cout << *it2 << std::endl;
        it2++;  // point to Moe
        std::cout << *it2 << std::endl;

        // iterator over a map
        std::map<std::string, std::string> favorites {
            {"Frank", "C++"},
            {"Bill", "Java"},
            {"James", "Haskell"}
        };
        auto it3 = favorites.begin();   // iterator over map of string, string pairs
        while (it3 != favorites.end()) {
            std::cout << it3->first << " : " << it3->second << std::endl;
            it3++;
        }
    }

    void test5() {
        // iterate over a subset of a container
        std::vector<int> vec {1,2,3,4,5,6,7,8,9,10};
        auto start = vec.begin() + 2;
        auto finish = vec.end() - 3;
        
        while (start != finish) {
            std::cout << *start << std::endl;
            start++;
        }
        
    }
    int main() {

    //    test1();
    //    test2();
    //    test3();
    //    test4();
        test5();
        return 0;
    }

*/


/* 10) introduction to stl algorithm 

    - stl algorithm work on sequence of container elements provided to them by an iterator
    - stl has many common and useful algorithms
    - many algorithm requires extra information in order to do their work
        - functors(function objects)
        - function pointers
        - lambda expressions (c++11)


    algorithms and iterators
        #include <algorithm>

        - different containers support different types of iterators
            - determine the types of algorithms supported
        - all stl algorithms expect iterators as arguments
            - determines the sequence obtained from the container
            
        

    Iterator invalidation
    ------------------------
    - Iterator points to container elements
    - it's possible iterators become invalid during processing
    - suppose we are iterating over a vector of 10 elements
        - and we clear() the vector while iterating? what happens?
        - undefined behavior - our iterators are pointing to invalid locations

    example algorithm -  find with primitive types
        - the find algorithm tries to locate the first occurrence of an element in an container
        - lots of variations
        - returns an iterator pointing to the located element or end()

            std::vector<int> vec {1, 2, 3};
            auto loc = std::find(vec.begin(), vec.end(), 3);
            if(loc != vec.end()){ // found it
                cout << *loc; // 3
            } 

    example algorithm - find with user defined types

    - find needs to be able to compare object
    - operator== is used and must be provided by your class

        std::vector<player> team { // already initialized };
        Player P {"Hero", 100, 12};

        auto loc = std::find(team.begin(), team.end(), p);
        if(loc != vec.end()){   
            cout << *loc; // operator<< called
            
        }  


    example algorithm - for_each
    - for_each algorithm applies a function to each element in the iterator sequence
    - function must be provided to the algorithm as
        - functors (function object)
        - function pointer
        - lambda expression (c++11)
    - let's square each element


        for_each - using a functor
        --------------------------
            struct Square_Functor{
                void operator()(int x){         // overload () operator
                    std::cout << x * x << " "; 
                }
            }; 

            Square_Functor square; // function object
            std::vector<int> vec {1, 2, 3, 4};  
            std::for_each(vec.begin(), vec.end(), square); // 1 4 9 16

        for_each - using a function pointer
        -----------------------------------
            void square(int x){ // function
                std::cout << x * x << " "; 
            }
            std::vector<int> vec {1,2,3,4};
            std::for_each(vec.begin(), vec.end(), square);    

        for_each - using a lambda expression
        ------------------------------------
            vector<int> vec {1,2,3,4};
            for_each(vec.begin(), vec.end(), 
                [](int x){cout << x * x << " "; });  



    // Section 20
    // Algorithms
    #include <iostream>
    #include <vector>
    #include <list>
    #include <algorithm>
    #include <cctype> 

    class Person {
        std::string name;
        int age;
    public:
        Person() = default;
        Person(std::string name, int age) 
            : name{name}, age{age}  {}
        bool operator<(const Person &rhs) const {
            return this->age < rhs.age;
        }
        bool operator==(const Person &rhs) const {
            return (this->name == rhs.name && this->age == rhs.age);
        }
    };

    // Find an element in a container
    void find_test() {
        std::cout << "\n========================" << std::endl;

        std::vector<int> vec {1,2,3,4,5};
        
        auto loc = std::find(std::begin(vec), std::end(vec), 1);
        
        if (loc != std::end(vec))
            std::cout << "Found the number: " << *loc <<  std::endl;
        else 
            std::cout << "Couldn't find the number" << std::endl;
            
        std::list<Person> players {
            {"Larry", 18},
            {"Moe", 20},
            {"Curly", 21}
        };
        
        auto loc1 = std::find(players.begin(), players.end(), Person{"Moe", 20});
        if (loc1 != players.end())
            std::cout << "Found  Moe" << std::endl;
        else
            std::cout << "Moe not found" << std::endl;
    }

    // Count the number of elements in a container
    void count_test() {
        std::cout << "\n========================" << std::endl;

        std::vector<int> vec {1,2,3,4,5,1,2,1};
        
        int num = std::count(vec.begin(), vec.end(), 1);
        std::cout << num << " occurrences found" << std::endl;
    }

    // Count the number of occurences of an element in a container
    // based on a predicate using a lambda expression

    void count_if_test() {
        std::cout << "\n========================" << std::endl;

        // count only if the element is even
        std::vector<int> vec {1,2,3,4,5,1,2,1,100};
        int num = std::count_if(vec.begin(), vec.end(), [](int x) { return x %2 == 0; });
        std::cout << num << " even numbers found" << std::endl;
        
        num = std::count_if(vec.begin(), vec.end(), [](int x) { return x %2 != 0; });
        std::cout << num << " odd numbers found" << std::endl;
        
        // how can we determine how many elements in vec are >= 5?
        num = std::count_if(vec.begin(), vec.end(), [](int x) { return x>=5;   });
        std::cout << num << "  numbers are >= 5" << std::endl;

    }

    // Replace occurrences of elements in a container
    void replace_test() {
        std::cout << "\n========================" << std::endl;

        std::vector<int> vec {1,2,3,4,5,1,2,1};
        for (auto i: vec) {
            std::cout << i << " ";
        }
        std::cout << std::endl;
        
        std::replace(vec.begin(), vec.end(), 1, 100);
        for (auto i: vec) {
            std::cout << i << " ";
        }
        std::cout << std::endl;
    }

    void all_of_test() {
        std::vector<int> vec1 {1,3,5,7,9,1,3,13,19,5};
        if (std::all_of(vec1.begin(), vec1.end(), [](int x) { return x > 10; }))
            std::cout << "All the elements are > 10" << std::endl;
        else    
            std::cout << "Not all the elements are > 10" << std::endl;
        
        if (std::all_of(vec1.begin(), vec1.end(), [](int x) { return x < 20; }))
            std::cout << "All the elements are < 20" << std::endl;
        else    
            std::cout << "Not all the elements are < 20" << std::endl;        
    }

    // Transform elements in a container - string in this example
    void string_transform_test() {
        std::cout << "\n========================" << std::endl;

        std::string str1 {"This is a test"};
        std::cout << "Before transform: " << str1 << std::endl;
        std::transform(str1.begin(), str1.end(), str1.begin(), ::toupper);
        std::cout << "After transform: " << str1 << std::endl;
    }

    int main() {
        find_test();
    //    count_test();
    //    count_if_test();
    //    replace_test();
    //    all_of_test();
    //    string_transform_test();

        return 0;
    }

*/



/* 12) sequence container

    std::array (c++11)

    #include <array>

    - fixed size
        - sized must be known at compile time
    - direct element access
    - provides access to the underlying raw array
    - use instead of raw arrays when possible
    - all iterators available and do not invalidate


    // Section 20
    // std::array
    #include <iostream>
    #include <array>
    #include <algorithm>
    #include <numeric>  // for more algorithms like accumulate

    // Display the array -- note the size MUST be included
    // when passing a std::array to a function
    void display(const std::array<int, 5> &arr) {
        std::cout << "[ ";
        for (const auto &i: arr)
            std::cout << i << " ";
        std::cout <<  "]"<< std::endl;
    }

    void test1() {
        std::cout << "\nTest1 =========================" << std::endl;
        std::array<int, 5> arr1 {1,2,3,4,5};     // double {{ }} if C++ 11
        std::array<int, 5> arr2;
        
        display(arr1);
        display(arr2);          // Elements are not initialized (contain 'garbage')
            
        arr2  = {10,20,30,40,50};

        display(arr1);
        display(arr2);
        
        std::cout << "Size of arr1 is: " << arr1.size() << std::endl;       //5 
        std::cout << "Size of arr2 is: " << arr2.size() << std::endl;       //5
        
        arr1[0] = 1000;
        arr1.at(1) = 2000;
        display(arr1);

        std::cout << "Front of arr2: " << arr2.front() << std::endl;        // 10
        std::cout << "Back of arr2: " << arr2.back() << std::endl;          // 50
    }
    
    void test2() {
        std::cout << "\nTest2 =========================" << std::endl;
        std::array<int, 5> arr1 {1,2,3,4,5};     // double {{ }} is C++ 11
        std::array<int, 5> arr2 {10,20,30,40,50};
        
        display(arr1);
        display(arr2);
        
        arr1.fill(0);
        
        display(arr1);
        display(arr2);
        
        arr1.swap(arr2);
        
        display(arr1);
        display(arr2);
    }

    void test3() {
        std::cout << "\nTest3 =========================" << std::endl;

        std::array<int, 5> arr1 {1,2,3,4,5};     // double {{ }} is C++ 11

        int *ptr = arr1.data();
        std::cout << ptr << std::endl;
        *ptr = 10000;
        
        display(arr1);
    }

    void test4() {
        std::cout << "\nTest4 =========================" << std::endl;

        std::array<int, 5> arr1 {2,1,4,5,3};     // double {{ }} is C++ 11
        display(arr1);
        
        std::sort(arr1.begin(), arr1.end());
        display(arr1);
    }

    void test5() {
        std::cout << "\nTest5 =========================" << std::endl;

        std::array<int, 5> arr1 {2,1,4,5,3};     // double {{ }} is C++ 11

        std::array<int,5>::iterator min_num = std::min_element(arr1.begin(), arr1.end());
        auto max_num = std::max_element(arr1.begin(), arr1.end());
        std::cout << "min: " << *min_num << " , max: " << *max_num << std::endl;
    }

    void test6() {
        std::cout << "\nTest6 =========================" << std::endl;

        std::array<int, 5> arr1 {2,1,3,3,5};     // double {{ }} is C++ 11

        auto adjacent = std::adjacent_find(arr1.begin(), arr1.end());
        if (adjacent != arr1.end()) 
            std::cout << "Adjacent element found with value: " << *adjacent << std::endl;
        else 
            std::cout << "No adjacent elements found" << std::endl;
    }

    void test7() {
        std::cout << "\nTest7 =========================" << std::endl;

        //accumulate is from #include <numeric>
        std::array<int, 5> arr1 {1,2,3,4,5};     // double {{ }} is C++ 11

        int sum = std::accumulate(arr1.begin(), arr1.end(), 0);
        std::cout << "Sum of the elements in arr1 is: " << sum << std::endl;
    }

    void test8() {
        std::cout << "\nTest8 =========================" << std::endl;
        std::array<int, 10> arr1 {1,2,3,1,2,3,3,3,3,3};
        
        int count = std::count(arr1.begin(), arr1.end(), 3);
        std::cout << "Found 3 : " << count << " times" << std::endl;
    }

    void test9() {
        std::cout << "\nTest9 =========================" << std::endl;
        std::array<int, 10> arr1 {1, 2, 3, 50, 60, 70, 80, 200, 300 ,400};
        // find how many numbers are between 10 and 200 ->  50,60,70,80
        
        int count = std::count_if(arr1.begin(), arr1.end(), 
                                                [](int x) { return x>10 && x<200; });
                                                
        std::cout << "Found  " << count << " matches" << std::endl;
    }


    int main()  {    

        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        
        return 0;
    }



*/


