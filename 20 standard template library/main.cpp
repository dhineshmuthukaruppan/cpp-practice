/* 1) overview

    - what is STL
    - generic programming / meta programming
        - preprocessor macros
        - function templates
        - class templates
    - stl containers
    - stl iterators
    - stl algorithms
    - array
    - vector
    - deque
    - list and forward list
    - set and multiset
    - map and multimap
    - stack and queue
    - priority queue
    - algorithms

 */


/* 2) what is stl

    - a library of powerful, reusable, adaptable, generic classes and functions
    - implemented using c++ templates
    - implements common data structures and algorithms
    - huge class library


    why use the stl?
    - assortment of commonly used containers
    - known time and size complexity
    - tried and tested - reusability
    - consistent, fast, and type safe
    - extensible

    elements of stl
    ----------------
    - containers
        - collection of objects or primitive types
            (array, vector, deque, stack, set, map etc.)
        
    - algorithms
        - functions for processing sequences of elements from containers
            (find, max, count, accumulate, sort, etc.)

    - iterators
        - generate sequences of elements from containers
            (forward, reverse, by value, by reference, constant, etc)


    types of containers
    ------------------
    - sequence of containers
        - array, vector, list, forward_list, deque
    
    - associative containers
        - set, multiset, map, multimap
    
    - container adapters
        - stack, queue, priority queue

    types of iterators
    -----------------
    - input iterators - from the container to the program
    - output iterators - from the program to the container
    - forward iterators - navigate one item at a time in one direction
    - bidirectional iterators - navigate one item at a time both directions
    - random access iterators - directly access a container item

    types of algoritms
    -  about 60 algorithms in stl
    - non modifying
    - modifying
    

*/

/* 3) generic programming with macros 

    generic programming 
        - writing code that works with a variety of types as arguments, as long as those 
        argument types meet specific syntactic and semantic requirements

    - macros ***beware***
    - function templates
    - class templates

    Macros (#define)

    - c++ preprocessor directives
    - no type information
    - simple substitution

        #define MAX_SIZE 100
        #define PI 3.14

    #define MAX(a, b) ((a > b) ? a : b)
    cout << MAX(10, 20); // 20
    cout << MAX(2.4, 3.4); // 3.4
    

    - we have to be careful with macros
        #define SQUARE(a) a*a

        result = SQUARE(5); // EXPECT AND GETS 25

        result = 100 / SQUARE(5); // expect 4 and gets 100



        soln:
            wrap up macros
            #define SQUARE(a) ((a) * (a))  // note the parenthesis

*/


/* 4) generic programming with function templates 

    - what is c++ template?
        - blue print
        - function and class templates
        - allow plugging in any data type
        - compiler generates the appropriate function / class from the blue print
        - generic programming / meta - programming

    max function as a template function

    - we can replace type we want to generalize with a name, say T
    - but now this won't compile
    - we need to tell the compiler this is a template function
    - we also need to tell it that T is the template parameter
    - code is not generated by the compiler until the user uses a specialized version of the template
    - many times the compiler can deduce the type and the template parameter is not needed
    - depending on the type of a and b, the compiler will figure it out


    template <typename T>
    T max(T a, T b){
        return (a > b) ? a : b;
    }

    cout << max<double>(a, b);   
    cout << max<Player>(p1, p2); // will not compile unless player overloads operator >
    

    - multiple types as template parameters
    ---------------------------------------
    - we can have multiple template parameters
    - and their types can be different

        template<typename T1, typename T2>  
        void func(T1 a, T2 b){
            cout << a << b; 
        }
        
        // when we use the function we provide the template parameters
        // ofteh the compiler can deduce them
        func<int, double>(10, 20.2);
        func('A', 12.4);   
        

    // Section 20
    // Function templates
    #include <iostream>
    #include <string>

    template <typename T>
    T min(T a, T b) {
        return (a < b) ? a : b;
    }

    template <typename T1, typename T2>
    void func(T1 a, T2 b) {
        std::cout << a << " " << b << std::endl;
    }

    struct Person {
        std::string name;
        int age;
        bool operator<(const Person &rhs) const {
            return this->age < rhs.age;
        }
    };

    std::ostream &operator<<(std::ostream &os, const Person &p) {
        os << p.name;
        return os;
    }

    template <typename T>
    void my_swap(T &a, T &b) {    
        T temp = a;
        a = b;
        b = temp;
    }

    int main() {
        int x{100};
        int y{200};
        std::cout << x << ", " << y << std::endl;
        my_swap(x, y);
        std::cout << x << ", " << y << std::endl;
        
        Person p1 {"Curly", 15};
        Person p2 {"Moe", 30};
        
        Person p3 = min(p1, p2);
        std::cout << p3.name << " is younger" << std::endl;
        
        func(p1, p2);
        
        std::cout << min<int>(2,3) << std::endl;        // 2
        std::cout << min(2,3) << std::endl;                 // 2
        std::cout << min('A', 'B') << std::endl;            // A
        std::cout << min(12.5, 9.2) << std::endl;        // 9.2
        std::cout << min(5+2*2, 7+40) << std::endl; // 9
        
        func<int,int>(10,20);
        func(10,20);
        func<char, double>('A', 12.4);
        func('A', 12.4);
        func(1000, "Testing");
        func(2000, std::string{"Frank"});
        

        return 0;
    }
*/



/* 5) generic programming with class templates 

    - what is c++ class template?
        - similar to function template, but at the class level
        - allows plugging-in any data type
        - compiler generates the appropriate class from the blueprint

    - Generic programming with class templates
        - but we'd like our Item class to be able to hold any type of data in addtion to the string
        - we can't overload class names 
        - we don't want to use dynamic polymorphism

    // Section 20
    // Class  templates
    #include <iostream>
    #include <string>
    #include <vector>

    // Template classes are typically completely contained in header files
    // So, we would have the template class in Item.h and no Item.cpp file
    // would be used
    template <typename T>
    class Item {
    private:
        std::string name;
        T   value;
    public:
        Item(std::string name, T value) : name{name}, value{value} 
        {}
        std::string get_name() const {return name; }
        T get_value() const { return value; }
    };

    template <typename T1, typename T2>
    struct My_Pair {
        T1 first;
        T2 second;
    };

    int main() {
        
        Item<int> item1 {"Frank", 100};
        std::cout << item1.get_name() << " " << item1.get_value() << std::endl;
        
        Item  <std::string> item2 {"Frank", "Professor"};
        std::cout << item2.get_name() << " " << item2.get_value() << std::endl;
        
        Item <Item<std::string>> item3 {"Frank",  {"C++", "Professor"}};
        std::cout << item3.get_name() << " " 
                        << item3.get_value().get_name() << " "
                        << item3.get_value().get_value() << std::endl;
        
        std::cout << "\n================================" << std::endl;
        std::vector<Item<double>> vec {};
        vec.push_back (Item<double>("Larry", 100.0));
        vec.push_back (Item<double>("Moe", 200.0));
        vec.push_back (Item<double>("Curly",300.0));
        
        for (const auto &item: vec) {
            std::cout << item.get_name() << " " << item.get_value() << std::endl;
        }
    
        std::cout << "\n================================" << std::endl;
        My_Pair <std::string, int> p1 {"Frank", 100};
        My_Pair <int, double> p2 {124, 13.6};

        std::cout << p1.first << ", " << p1.second << std::endl;
        std::cout << p2.first << ", " << p2.second << std::endl;
        
        return 0;
    }

*/


/* 6) creating a generic array template class 

    // Section 20
    // Class template - Array

    // Note: Since C++11 the STL has std::array which is a template-based array class
    // Use std::array instead of raw arrays whenever possible

    // Note that we can have non-type template parameters
    // That's what N is in this case

    #include <iostream>
    #include <string>

    template <typename T, int N>
    class Array {
        int size {N};           // how do we get the N???
        T values[N];        // the N needs to ne known at compile-time!

        friend std::ostream &operator<<(std::ostream &os, const Array<T, N> &arr) {
            os << "[ ";
            for (const auto &val: arr.values)
                os << val << " ";
            os << "]" << std::endl;
            return os;
        }
    public:
        Array() = default;
        Array(T init_val) {
            for (auto &item: values)
                item = init_val;
        }
        void fill(T val) {
            for (auto &item: values )
                item = val;
        }
        int get_size() const {
            return size;
        }
        // overloaded subscript operator for easy use
        T &operator[](int index) {
            return values[index];
        }
    };


    int main() {
        
        Array<int, 5> nums;
        std::cout << "The size of nums is: "<< nums.get_size() << std::endl;
        std::cout << nums << std::endl;
        
        nums.fill(0);
        std::cout << "The size of nums is: "<< nums.get_size() << std::endl;
        std::cout << nums << std::endl;
        
        nums.fill(10);
        std::cout << nums << std::endl;

        nums[0] = 1000;
        nums[3] = 2000;
        std::cout << nums << std::endl;
        
        Array<int, 100> nums2 {1};
        std::cout << "The size of nums2 is: "<< nums2.get_size() << std::endl;
        std::cout << nums2 << std::endl;

        Array<std::string, 10> strings(std::string{"Frank"});
        std::cout << "The size of strings is: "<< strings.get_size() << std::endl;
        std::cout << strings << std::endl;
        
        strings[0] = std::string{"Larry"}; // strings.operator[](0); 
        std::cout << strings << std::endl;
        
        strings.fill(std::string{"X"});
        std::cout << strings << std::endl;

        
        return 0;
    }

*/



/* 7) introduction to stl containers 

    containers
    - data structures that can store object of almost any type
        - template-based classes
    
    - each container has member functions
        - some are specific to the container
        - others are available to all containers
    
    - each containers has an associated header file
        #include <container_type>


    common methods provided by the stl container
    --------------------------------------------
    - default constructor - initializes an empty container
    - overloaded constructors - initializes containers with many options
    - copy constructors - initializes container as a copy of another container
    - move constructor - moves existing container to new container
    - destructor - destroys a container
    - copy assignment (operator=) - copy one container to another
    - move assignment (operator=) - move one container to another
    - size - returns the number of elements in the container
    - empty - returns boolean - is container empty?
    - insert - insert an element into the container

    - operator< and operator<=
    - operator> and operator>= - returns boolean compare contents of 2 containers
    - operator== and operator!= 
    - swap - swap the elements of 2 containers
    - erase - remove element(s) from a container
    - clear - remove all elements from a container
    - begin and end - returns iterators to first element or end
    - rbegin and rend - returns reverse iterators to first element or end
    - cbegin and cend - returns constant iterators to first element or end
    - crbegin and crend - returns constant reverse iterators to first element or end

*/


/* 9) introduction to iterators 

    *** iterator is not pointing to the real pointer

    // Section 20
    // Iterators
    #include <iostream>
    #include <vector>
    #include <set>
    #include <map>
    #include <list>

    // display any vector of integers using range-based for loop
    void display(const std::vector<int> &vec) {
        std::cout << "[ ";
        for (auto const &i: vec) {
            std::cout << i << " ";
        }
        std::cout << "]" << std::endl;
    }

    void test1() {
        std::cout << "\n=============================" << std::endl;
        std::vector<int> nums1 {1, 2, 3, 4, 5};
        auto it = nums1.begin();            // point to 1
        std::cout << *it << std::endl;

        it++;                                           // point to 2
        std::cout << *it << std::endl;      

        it += 2;                                       // point to 4
        std::cout << *it << std::endl;

        it -= 2;                                        // point to 2
        std::cout << *it << std::endl;

        it = nums1.end() - 1;                   // point to 5
        std::cout << *it << std::endl;
    }

    void test2() {
        std::cout << "\n=============================" << std::endl;
        // display all vector elements using an iterator
        
        std::vector<int> nums1 {1, 2, 3, 4, 5};

        std::vector<int>::iterator it = nums1.begin();
        while (it != nums1.end()) {
            std::cout << *it << std::endl;
            it++;
        }
        
        // change all vector elements to 0
        it = nums1.begin();
        while (it != nums1.end()) {
            *it = 0;
            it++;
        }

        display(nums1);
    }

    void test3() {
        
        // using a const_iterator
        std::cout << "\n=============================" << std::endl;
        std::vector<int> nums1 {1, 2, 3, 4, 5};

        std::vector<int>::const_iterator it1 = nums1.begin();
        // auto it1 = nums1.cbegin();
        
        while (it1 != nums1.end()) {
            std::cout << *it1 << std::endl;
            it1++;
        }
        
        // compiler error when we try to change element
        it1 = nums1.begin();
        while (it1 != nums1.end()) {
        // *it1 = 0;   // Complier error - read only
            it1++;
        }

    }

    void test4() {
        // more iterators
        // using a reverse iterator
        std::vector<int> vec {1,2,3,4};
        auto it1  = vec.rbegin();       // reverse iterator over vector of ints starts at 4
        while (it1 != vec.rend()) {
            std::cout << *it1 << std::endl;
            it1++;
        }

        // const reverse iterator over a list
        std::list<std::string> name {"Larry", "Moe", "Curly"};
        auto it2 =name.crbegin();    // iterator over list of strings  point to Curly
        std::cout << *it2 << std::endl;
        it2++;  // point to Moe
        std::cout << *it2 << std::endl;

        // iterator over a map
        std::map<std::string, std::string> favorites {
            {"Frank", "C++"},
            {"Bill", "Java"},
            {"James", "Haskell"}
        };
        auto it3 = favorites.begin();   // iterator over map of string, string pairs
        while (it3 != favorites.end()) {
            std::cout << it3->first << " : " << it3->second << std::endl;
            it3++;
        }
    }

    void test5() {
        // iterate over a subset of a container
        std::vector<int> vec {1,2,3,4,5,6,7,8,9,10};
        auto start = vec.begin() + 2;
        auto finish = vec.end() - 3;
        
        while (start != finish) {
            std::cout << *start << std::endl;
            start++;
        }
        
    }
    int main() {

    //    test1();
    //    test2();
    //    test3();
    //    test4();
        test5();
        return 0;
    }

*/









