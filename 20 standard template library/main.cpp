/* 1) overview

    - what is STL
    - generic programming / meta programming
        - preprocessor macros
        - function templates
        - class templates
    - stl containers
    - stl iterators
    - stl algorithms
    - array
    - vector
    - deque
    - list and forward list
    - set and multiset
    - map and multimap
    - stack and queue
    - priority queue
    - algorithms

 */


/* 2) what is stl

    - a library of powerful, reusable, adaptable, generic classes and functions
    - implemented using c++ templates
    - implements common data structures and algorithms
    - huge class library


    why use the stl?
    - assortment of commonly used containers
    - known time and size complexity
    - tried and tested - reusability
    - consistent, fast, and type safe
    - extensible

    elements of stl
    ----------------
    - containers
        - collection of objects or primitive types
            (array, vector, deque, stack, set, map etc.)
        
    - algorithms
        - functions for processing sequences of elements from containers
            (find, max, count, accumulate, sort, etc.)

    - iterators
        - generate sequences of elements from containers
            (forward, reverse, by value, by reference, constant, etc)


    types of containers
    ------------------
    - sequence of containers
        - array, vector, list, forward_list, deque
    
    - associative containers
        - set, multiset, map, multimap
    
    - container adapters
        - stack, queue, priority queue

    types of iterators
    -----------------
    - input iterators - from the container to the program
    - output iterators - from the program to the container
    - forward iterators - navigate one item at a time in one direction
    - bidirectional iterators - navigate one item at a time both directions
    - random access iterators - directly access a container item

    types of algoritms
    -  about 60 algorithms in stl
    - non modifying
    - modifying
    

*/

/* 3) generic programming with macros 

    generic programming 
        - writing code that works with a variety of types as arguments, as long as those 
        argument types meet specific syntactic and semantic requirements

    - macros ***beware***
    - function templates
    - class templates

    Macros (#define)

    - c++ preprocessor directives
    - no type information
    - simple substitution

        #define MAX_SIZE 100
        #define PI 3.14

    #define MAX(a, b) ((a > b) ? a : b)
    cout << MAX(10, 20); // 20
    cout << MAX(2.4, 3.4); // 3.4
    

    - we have to be careful with macros
        #define SQUARE(a) a*a

        result = SQUARE(5); // EXPECT AND GETS 25

        result = 100 / SQUARE(5); // expect 4 and gets 100



        soln:
            wrap up macros
            #define SQUARE(a) ((a) * (a))  // note the parenthesis

*/


/* 4) generic programming with function templates 

    - what is c++ template?
        - blue print
        - function and class templates
        - allow plugging in any data type
        - compiler generates the appropriate function / class from the blue print
        - generic programming / meta - programming

    max function as a template function

    - we can replace type we want to generalize with a name, say T
    - but now this won't compile
    - we need to tell the compiler this is a template function
    - we also need to tell it that T is the template parameter
    - code is not generated by the compiler until the user uses a specialized version of the template
    - many times the compiler can deduce the type and the template parameter is not needed
    - depending on the type of a and b, the compiler will figure it out


    template <typename T>
    T max(T a, T b){
        return (a > b) ? a : b;
    }

    cout << max<double>(a, b);   
    cout << max<Player>(p1, p2); // will not compile unless player overloads operator >
    

    - multiple types as template parameters
    ---------------------------------------
    - we can have multiple template parameters
    - and their types can be different

        template<typename T1, typename T2>  
        void func(T1 a, T2 b){
            cout << a << b; 
        }
        
        // when we use the function we provide the template parameters
        // ofteh the compiler can deduce them
        func<int, double>(10, 20.2);
        func('A', 12.4);   
        

    // Section 20
    // Function templates
    #include <iostream>
    #include <string>

    template <typename T>
    T min(T a, T b) {
        return (a < b) ? a : b;
    }

    template <typename T1, typename T2>
    void func(T1 a, T2 b) {
        std::cout << a << " " << b << std::endl;
    }

    struct Person {
        std::string name;
        int age;
        bool operator<(const Person &rhs) const {
            return this->age < rhs.age;
        }
    };

    std::ostream &operator<<(std::ostream &os, const Person &p) {
        os << p.name;
        return os;
    }

    template <typename T>
    void my_swap(T &a, T &b) {    
        T temp = a;
        a = b;
        b = temp;
    }

    int main() {
        int x{100};
        int y{200};
        std::cout << x << ", " << y << std::endl;
        my_swap(x, y);
        std::cout << x << ", " << y << std::endl;
        
        Person p1 {"Curly", 15};
        Person p2 {"Moe", 30};
        
        Person p3 = min(p1, p2);
        std::cout << p3.name << " is younger" << std::endl;
        
        func(p1, p2);
        
        std::cout << min<int>(2,3) << std::endl;        // 2
        std::cout << min(2,3) << std::endl;                 // 2
        std::cout << min('A', 'B') << std::endl;            // A
        std::cout << min(12.5, 9.2) << std::endl;        // 9.2
        std::cout << min(5+2*2, 7+40) << std::endl; // 9
        
        func<int,int>(10,20);
        func(10,20);
        func<char, double>('A', 12.4);
        func('A', 12.4);
        func(1000, "Testing");
        func(2000, std::string{"Frank"});
        

        return 0;
    }
*/



/* 5) generic programming with class templates 

    - what is c++ class template?
        - similar to function template, but at the class level
        - allows plugging-in any data type
        - compiler generates the appropriate class from the blueprint


        

*/